{"version":3,"file":"main.js","sources":["../src/nBodyVisualizer.js","../src/nBodySimulator.js","../src/main.js"],"sourcesContent":["/**\n * This is a toolkit of visualizers for our simulation.\n */\n\n/**\n * Base class that console.log()s the simulation state.\n */\nexport class nBodyVisualizer {\n  constructor(htmlElement) {\n    this.htmlElement = htmlElement\n    this.resize()\n  }\n\n  resize() {}\n\n  paint(bodies) {\n    console.log(JSON.stringify(bodies, null, 2))\n  }\n\n}\n\n/**\n * Pretty print simulation to an htmlElement's innerHTML\n */\nexport class nBodyVisPrettyPrint extends nBodyVisualizer {\n  constructor(htmlElement) {\n    super(htmlElement)\n    this.isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);\n  }\n\n  resize() {}\n\n  paint(bodies) {\n    \n    if (this.isMobile) return\n\n    let text = ''\n    function pretty(number) {\n      return number.toPrecision(2).padStart(10)\n    }\n    bodies.forEach( body => {\n      text += `<br>${body.name.padStart(12)} {  x:${pretty(body.x)}  y:${pretty(body.y)}  z:${pretty(body.z)}  mass:${pretty(body.mass)}) }`\n    })\n    if (this.htmlElement) this.htmlElement.innerHTML = text\n  }\n}\n\n/**\n * Draw simulation state to Canvas\n */\nexport class nBodyVisCanvas extends nBodyVisualizer {\n  constructor(htmlElement) {\n    super(htmlElement)\n\n    // Listen for resize to scale our simulation\n    window.onresize = this.resize.bind(this)\n  }\n\n  // If the window is resized, we need to resize our visualization\n  resize() {\n    if (!this.htmlElement) return\n    this.sizeX = this.htmlElement.offsetWidth\n    this.sizeY = this.htmlElement.offsetHeight\n    this.htmlElement.width = this.sizeX\n    this.htmlElement.height = this.sizeY\n    this.vis = this.htmlElement.getContext('2d')\n  }\n\n  // Paint on the canvas\n  paint(bodies) {\n    if (!this.htmlElement) return\n    // We need to convert our 3d float universe to a 2d pixel visualization\n    // calculate shift and scale\n    const bounds = this.bounds(bodies)\n    const shiftX = bounds.xMin\n    const shiftY = bounds.yMin\n    const twoPie = 2 * Math.PI\n    \n    let scaleX = this.sizeX / (bounds.xMax - bounds.xMin)\n    let scaleY = this.sizeY / (bounds.yMax - bounds.yMin)\n    if (isNaN(scaleX) || !isFinite(scaleX) || scaleX < 15) scaleX = 15\n    if (isNaN(scaleY) || !isFinite(scaleY) || scaleY < 15) scaleY = 15\n\n    // Begin Draw\n    this.vis.clearRect(0, 0, this.vis.canvas.width, this.vis.canvas.height)\n    bodies.forEach((body, index) => {\n      // Center\n      const drawX = (body.x - shiftX) * scaleX\n      const drawY = (body.y - shiftY) * scaleY\n      // Draw on canvas\n      this.vis.beginPath();\n      this.vis.arc(drawX, drawY, body.drawSize, 0, twoPie, false);\n      this.vis.fillStyle = body.color || \"#aaa\"\n      this.vis.fill();\n    });\n  }\n\n  // Because we draw the 3d space in 2d from the top, we ignore z\n  bounds(bodies) {\n    const ret = { xMin: 0, xMax: 0, yMin: 0, yMax: 0, zMin: 0, zMax: 0 }\n    bodies.forEach(body => {\n      if (ret.xMin > body.x) ret.xMin = body.x\n      if (ret.xMax < body.x) ret.xMax = body.x\n      if (ret.yMin > body.y) ret.yMin = body.y\n      if (ret.yMax < body.y) ret.yMax = body.y\n      if (ret.zMin > body.z) ret.zMin = body.z\n      if (ret.zMax < body.z) ret.zMax = body.z\n    })\n    return ret\n  }\n}\n","/**\n * This creates an n-body simulation in 3d space using mass, distance, and gravity.\n * \n * Example usage:\n * \n * const sim = new nBodySimulator()\n * \n * sim.addVisualization(new nBodyVisPrettyPrint())\n * sim.addVisualization(new nBodyVisCanvas())\n * \n * // Set Z coords to 1 for best visualiztion in overhead 2d Canvas\n * sim.addBody(new Body(1, 1, 1, 100))\n * \n * // Start simulation with empty universe, then add bodies.  \n * sim.start()\n * sim.addBody(new Body(-1, -1, 1, 100))\n * sim.addBody(new Body(2, -2, 1, 100))\n */\n\n/**\n * Body doesn't do much and resists change.  For our purposes, negative mass is fun.\n * \n * If pX or pY are unspecified, we give the body random initial momentum \n * so the spinny doesn't devolve to weird oscilating linear orbit\n \n * No collisions or splody are implemented.\n */\nexport class Body {\n  constructor(name, color, x, y, z, mass, vX, vY, vZ) {\n    this.name = name\n    this.color = color\n    this.x = x\n    this.y = y\n    this.z = z\n    this.mass = mass\n    \n    this.vX = vX || 0\n    this.vY = vY || 0\n    this.vZ = vZ || 0\n\n    this.forceX = 0\n    this.forceY = 0\n    this.forceZ = 0\n\n    this.drawSize = Math.min(   Math.max( Math.log10(mass), 1),   10)\n  }\n}\n\n\n/**\n * Our n-body system simulator\n */\nexport class nBodySimulator {\n\n  constructor() {\n    this.setupWebWorker()\n\n    // 1000 ms/s / 33 ms/frame = 30 frame/sec.  FIXME this could be replaced with requestAnimationFrame()\n    this.simulationSpeed = 33\n\n    // Source of truth\n    this.objBodies = []\n    \n    // used to index arrBodies\n    this.bodySize = 4   // x,y,z,mass\n\n    // used to index arrForces\n    this.forceSize = 3  // x,y,z\n\n    // Debris bounds.  see trimDebris().\n    this.debrisBounds = 12\n\n    // Has the worker been setup?\n    this.workerReady = false\n    // Is the worker calculating\n    this.workerCalculating = false\n\n    // Array of our visualizations\n    this.visualizations = []\n  }\n\n  /**\n   * Is the simulation ready to calculate\n   */\n  ready() {\n    return this.workerReady && !this.workerCalculating\n  }\n\n  /**\n   * Add a body to the simulation.\n   */\n  addBody(body) {\n    this.objBodies.push(body)\n  }\n\n  /**\n   * Start the simulation loop\n   */\n  start() {\n    // This is the simulation loop.  step() calls visualize()\n    const step = this.step.bind(this)\n    setInterval(step, this.simulationSpeed)\n  }\n\n  /**\n   * This is the simulation loop.\n   */\n  async step() {\n    // Skip calculation if worker not ready.  We scheduled this to run every 33ms (30fps), so expect it to skip.\n    if (this.ready()) {\n      await this.calculateForces()\n    } else {\n      console.log(`Skipping calcuation:  WorkerReady: ${this.workerReady}   WorkerCalculating: ${this.workerCalculating}`)\n    }\n    // Remove any \"debris\" that has traveled out of bounds - this is for the button\n    this.trimDebris()\n\n    // Now Update forces.  Reuse old forces if worker is already busy calculating.\n    this.applyForces()\n\n    // Now Visualize\n    this.visualize()\n  }\n\n  /** \n   * Use our web worker to calculate the forces to apply on our bodies.\n   */\n  calculateForces() {\n    this.workerCalculating = true\n    this.arrBodies = []\n\n    // Copy data to array\n    this.objBodies.forEach((body, index) => {\n      const b = index * this.bodySize\n      this.arrBodies[b] = body.x\n      this.arrBodies[b + 1] = body.y\n      this.arrBodies[b + 2] = body.z\n      this.arrBodies[b + 3] = body.mass\n    })\n\n    // return promise that worker.onmessage will fulfill\n    const ret = new Promise((resolve, reject) => {\n      this.forcesResolve = resolve\n      this.forcesReject = reject\n    })\n    \n    // postMessage() to worker to start calculation\n    // Execution continues in workerWasm.js worker.onmessage()\n    this.worker.postMessage({ \n      purpose: 'nBodyForces',\n      arrBodies: this.arrBodies,\n    })\n\n    // Return promise for completion\n    // Promise is resolve()d in this.worker.onmessage() below.\n    // Once resolved, execution continees in step() above - await this.calculateForces()\n    return ret\n  }\n\n  /**\n   * Trim debris.  We let the player/user throw random bits into the universe for fun.\n   * But fun means watching it fly off, not the vis camera fly around.\n   * So we remove stuff that's gotten out of bounds\n   */\n  trimDebris() {\n    this.objBodies = this.objBodies.filter( body => {\n      if (body.name !==\"debris\") return true\n      if (isNaN(body.x) || isNaN(body.y) || isNaN(body.z)) return false\n      if (body.x < -this.debrisBounds || body.x > this.debrisBounds) return false\n      if (body.y < -this.debrisBounds || body.y > this.debrisBounds) return false\n      if (body.z < -this.debrisBounds || body.z > this.debrisBounds) return false\n      return true\n    })\n  }\n\n  /**\n   * Apply those forces.  Yes, this could be moved out of the UI thread,\n   * but passing objects across Wasm boundaries is dumb-hard - the kind of hard that is neither fun nor profitable.\n   * \n   * Physics:\n   * \n   * V = d/t             Velocity = distance / time\n   * P = mV              Momentum = mass * Velocity\n   * F = ma              Force = mass * acceleration\n   * \n   * Given the positions and mass of our bodies, we calculated the Grav forces applied in arrForces.\n   * \n   * Now, we want to push the bodies around using the forces.\n   * \n   * This is me trying to remember how to do high school physics.\n   * \n   * Given our positions and forces, \n   * \n   * F = ma.            Known F (wasm) and m (body)\n   * a = F/m.           Known a\n   * a = dV / t.        Known t (1/tick) - we will apply previous forces, so t always = 1\n   * F/m = dV / t\n   * dV = Ft/m\n   * V2 = V1 + dV       Known dV, V1\n   * x2 = x1 + V2 * t   Known x1, V2, t\n   * \n   * x2 = x1 + (V1 + (F/m))\n   * \n   * body.vX = body.vX + body.forceX / body.mass\n   * body.x = body.x + body.vX\n   */\n  applyForces() {\n    this.objBodies.forEach( (body, i) => {\n\n      if (body.mass === 0 || !this.arrForces) return // 0 mass bodies are used to position the camera min viewin the canvas visualizer.\n\n      // Capture forces\n      body.forceX = this.arrForces[i * this.forceSize + 0]\n      body.forceY = this.arrForces[i * this.forceSize + 1]\n      body.forceZ = this.arrForces[i * this.forceSize + 2]\n\n      // Convert to velocity.  We could remove mass in nBodyForces.ts and just send velocities, but I'm moving this project to the done pile.\n      body.vX = body.vX + body.forceX / body.mass\n      body.vY = body.vY + body.forceY / body.mass  \n      body.vZ = body.vZ + body.forceZ / body.mass  \n\n      // Update position from velocity\n      body.x = body.x + body.vX\n      body.y = body.y + body.vY\n      body.z = body.z + body.vZ\n    })\n  }\n\n  /**\n   * Loop through our visualizers and paint()\n   */\n  visualize() {\n    this.visualizations.forEach(vis => {\n      vis.paint(this.objBodies)\n    })\n  }\n\n  /**\n   * Add a visualizer to our list\n   */\n  addVisualization(vis) {\n    this.visualizations.push(vis)\n  }\n\n  /**\n   * Setup our web worker - buckle up, let's get weird.\n   */\n  setupWebWorker() {\n\n    // Create a Web Worker (separate thread) that we'll pass the WebAssembly module to.         \n    this.worker = new Worker(\"workerWasm.js\");\n\n    // Console errors from workerWasm.js\n    this.worker.onerror = function (evt) {\n      console.log(`Error from Web Worker: ${evt.message}`);\n    }\n\n    // Listen for messages from workerWasm.js postMessage()\n    const self = this\n    this.worker.onmessage = function (evt) {\n      if (evt && evt.data) {\n        \n        // Messages are dispatched by purpose\n        const msg = evt.data\n        switch (msg.purpose) {\n\n          // worker has loaded the wasm module we compiled and sent.  Let the magic begin!\n          // See postmessage at the bottom of this function.\n\n          case 'wasmReady': \n            self.workerReady = true\n            break\n\n          // wasm has computed forces for us\n\n          case 'nBodyForces':\n            self.workerCalculating = false\n            // Accept/Reject the promise to resolve await this.calculateForces() in step() above\n            if (msg.error) {\n              self.forcesReject(msg.error)\n            } else {\n              self.arrForces = msg.arrForces\n              self.forcesResolve(self.arrForces)\n            }\n            break\n        }\n      }\n    }\n\n    // Fetch and compile the wasm module because web workers cannot fetch()\n    WebAssembly.compileStreaming(fetch(\"assembly/nBodyForces.wasm\"))\n    // Send the compiled wasm module to the worker as a message\n    .then(wasmModule => {\n      self.worker.postMessage({ purpose: 'wasmModule', wasmModule })\n    });\n  }\n}\n","import { nBodyVisPrettyPrint, nBodyVisCanvas } from \"./nBodyVisualizer\"\nimport { Body, nBodySimulator } from \"./nBodySimulator\"\n\nwindow.onload = function() {\n  // Create a Simulation\n  const sim = new nBodySimulator()\n  \n  // Add some visualizers\n  sim.addVisualization(new nBodyVisPrettyPrint(document.getElementById(\"visPrettyPrint\")))\n  sim.addVisualization(new nBodyVisCanvas(document.getElementById(\"visCanvas\")))\n  \n  // This is a simulation, using opinionated G = 6.674e-11\n  // So boring values are allowed and create systems that collapse over billions of years.\n\n  // For spinny, where distance = 1, masses of 1e10 are fun\n\n  // Set Z coords to 1 for best visualiztion in overhead 2d Canvas\n  // lol, making up stable universes is hard\n  //                   name            color     x    y    z    m      vz    vy   vz\n  sim.addBody(new Body(\"star\",         \"yellow\", 0,   0,   0,   1e9)) \n  sim.addBody(new Body(\"hot jupiter\",  \"red\",   -1,  -1,   0,   1e4,  .24,  -0.05,  0))\n  sim.addBody(new Body(\"cold jupiter\", \"purple\", 4,   4, -.1,   1e4, -.07,   0.04,  0))\n  // A couple far-out asteroids to pin the canvas visualization in place.\n  sim.addBody(new Body(\"asteroid\",     \"black\", -15,  -15,  0,  0))  \n  sim.addBody(new Body(\"asteroid\",     \"black\",  15,   15,  0,  0))\n\n  // Start simulation  \n  sim.start()\n  \n  // Add another\n  sim.addBody(new Body(\"saturn\",       \"blue\",  -8,  -8,  .1,   1e3,   .07,   -.035,  0))\n\n  // That is the extent of my effort to hand craft a stable solar system.\n\n  // We can now play in that system by throwing debris around (inner plants)\n  // Because that debris will have significanly smaller mass, it won't disturb our stable system (hopefully :-)\n  // This requires we remove bodies that fly out of bounds past our 15x15 astroids.  \n  // See sim.trimDebris().  It's a bit hacky, but my client (me) doesn't want to pay for it and wants the WebVR version\n\n  function rando(scale) {\n    return (Math.random()-.5) * scale\n  }\n\n  document.getElementById(\"mayhem\").addEventListener('click', () => {\n    for (let x=0; x<10; x++) {\n      sim.addBody(new Body(\"debris\", \"white\", rando(10), rando(10), rando(10), 1, rando(.1), rando(.1), rando(.1)))\n    }\n  })\n\n}\n"],"names":["nBodyVisualizer","[object Object]","htmlElement","this","resize","bodies","console","log","JSON","stringify","nBodyVisPrettyPrint","super","isMobile","test","navigator","userAgent","text","pretty","number","toPrecision","padStart","forEach","body","name","x","y","z","mass","innerHTML","nBodyVisCanvas","window","onresize","bind","sizeX","offsetWidth","sizeY","offsetHeight","width","height","vis","getContext","bounds","shiftX","xMin","shiftY","yMin","twoPie","Math","PI","scaleX","xMax","scaleY","yMax","isNaN","isFinite","clearRect","canvas","index","drawX","drawY","beginPath","arc","drawSize","fillStyle","color","fill","ret","zMin","zMax","Body","vX","vY","vZ","forceX","forceY","forceZ","min","max","log10","nBodySimulator","setupWebWorker","simulationSpeed","objBodies","bodySize","forceSize","debrisBounds","workerReady","workerCalculating","visualizations","push","step","setInterval","ready","calculateForces","trimDebris","applyForces","visualize","arrBodies","b","Promise","resolve","reject","forcesResolve","forcesReject","worker","postMessage","purpose","filter","i","arrForces","paint","Worker","onerror","evt","message","self","onmessage","data","msg","error","WebAssembly","compileStreaming","fetch","then","wasmModule","onload","sim","rando","scale","random","addVisualization","document","getElementById","addBody","start","addEventListener"],"mappings":"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"}